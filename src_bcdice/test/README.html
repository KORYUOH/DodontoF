<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>ダイスボットのつくりかた</title>
</head>
<body>
<h1>ダイスボットのつくりかた</h1>

<h2>■概要</h2>
ここでは「どどんとふ」のダイスボットを自作してみたい人用に具体的な手順について記述しています。<br/>
<br/>
<h2>■そもそもダイスボットって何？</h2>
「ダイス＋ロボット」でダイスボット。<br/>
元々はチャットソフトでダイスを振ってくれるロボットの用なツールを指す言葉ですね。<br/>
どどんとふではそのネーミングを引き継いでゲーム用のダイステキストを処理する機能を「ダイスボット」と呼んでいます。<br/>
<br/>
<h2>■ダイスボットの自作って？</h2>
どどんとふで遊ぼうと思ったゲームがダイスボットの一覧に無い。<br/>
そんな時にどうするか？<br/>
<br/>
作者に頼むのもモチロンいいですね。<br/>
<br/>
でも、超マイナールールだったり自作ＴＲＰＧだったり、あるいは単純にプログラミングってのが楽しそうだったり。<br/>
色んな理由で自分で作りたくなる時ってのはあるものです。<br/>
それが出来ちゃうのがどどんとふのダイスボットの魅力の一つ、というわけですね。<br/>
<br/>
どどんとふのダイスボットは「Ruby」というプログラミング言語でソースコードを書くことで追加・変更することができます。<br/>
「うっはープログラミングとかサッパリだわー」という人は、流石にこの先は読まなくてもOKです。<br/>
「Ruby！いいね！俺大好きなんだよ！」なんて酔狂な方はもちろんウェルカム！<br/>
でも、どちらかというと「Rubyかー、この機会にちょっと勉強してみようかな？」という方向けに説明進めていきましょうね。<br/>
<br/>
<h2>■環境の用意</h2>
それではWindows環境向けにダイスボットを自作するための手順を説明していきましょう。<br/>
＃Unix系OSの人なら当然Rubyはインストール済みと信じて説明は割愛。<br/>
ダイスボットの作成のためにはWindows用のRuby実行環境を作成する必要があります。<br/>
RubyInstallerから、「Ruby 1.9.X-pXXX」（Xは任意の数字）をダウンロードします。<br/>
<br/>
　<a href="http://rubyinstaller.org/">http://rubyinstaller.org/</a><br/>
<br/>
あとは、インストーラーの指示に従ってインストール。<br/>
そしてインストールディレクトリの bin にパスを通します。（パスを通す、の意味が知らない人はネットで検索だ！）<br/>
Ruby1.9.3のデフォルトだと「C:\Program Files\Ruby193\bin」ですかね。 ruby.exe のある場所にパスを通すのがポイントです。<br/>
後はコマンドプロンプト開いて（コマンドプロンプト、の意味が分からない人はネットで（略））、<br/>
ruby -v <br/>
とコマンドを実行して、Rubyのバージョン情報が表示されればOKです。<br/>
準備万端。それではダイスボットを作っていきましょう！<br/>
<br/>
<h2>■自作ダイスボットの作り方：その１　名前大事！</h2>
今回サンプルとして作るダイスボット用に架空のゲームシステムがあるとしましょう。<br/>
<hr/>
タイトル：仮ダイス
<hr/>
・判定方法<br/>
　6面ダイスをX個振るシステム。<br/>
　判定コマンドは<br/>
　　KDx>=y（xはダイスロール数、yは目標値）<br/>
<hr/>
<br/>
これをダイスボットで実装する方法を考えて行きましょう。<br/>
<br/>
まずは　diceBot　ディレクトリを開きます。<br/>
どどんとふ なら　src_bcdice/diceBot<br/>
B＆C Dice2.0 なら　src/diceBot<br/>
その中に　_Template.rb　という名前のファイルがあります。<br/>
<br/>
テンプレート、TRPGでもよく使われる単語ですね。<br/>
要は「ひな型」って意味でして、それをもとに作れば1から作るよりも楽だよーってニュアンスですね。<br/>
ではでは、そのニュアンスを信じて　_Template.rb　ファイルを元に作ってみましょう。<br/>
_Template.rb　ファイルをコピーして、今回のゲーム用のタイトルをファイル名に付けましょう。<br/>
タイトルが「仮ダイス」ですから<br/>
<br/>
　KariDice.rb<br/>
<br/>
ですかね。<br/>
このKariDiceという名前は「ダイスボットの型名」と呼んで他でも使いますので「ファイル名なんてなんでもいいや」とか思わずにしっかり決めてくださいね。<br/>
プログラミングでは命名が何より大事ですので。<br/>
この KariDice.rb　を以降は編集していきます。<br/>
<br/>
<h2>■自作ダイスボットの作り方：その２　まずは形から</h2>
KariDice.rb はまだ中身は　_Template.rb　ファイルのままですね。<br/>
この中身をチョイチョイっと書き換えて仮ダイスを実装していきましょう。<br/>
ファイルを開いて、<br/>
<br/>
class _Template < DiceBot<br/>
<br/>
ここを、今回のダイスボットは名前が 「KariDice」なので<br/>
<br/>
class KariDice < DiceBot<br/>
<br/>
と書き換え。ファイル名の（～.rb）部分と同じにするわけですね。<br/>
続いて<br/>
<pre><code>
  def gameName
    'ゲーム名'
  end
  
  def gameType
    "GameType"
  end
</code></pre>
を<br/>
<pre><code>
  def gameName
    '仮ダイス'
  end
  
  def gameType
    "KariDice"
  end
</code></pre>
に変更。<br/>
ゲームの日本語名とファイル名と同じ英文字での型名を定義しています。<br/>
では書き間違いがないか、念のため　KariDice.rb　の置いてあるディレクトリで<br/>
<br/>
　ruby -cw KariDice.rb<br/>
<br/>
とコマンドを実行しましょう。<br/>
<br/>
　Syntax OK<br/>
<br/>
と表示されれば問題ありません。<br/>
<br/>
エラーが表示される場合はそこに文法間違いがあるので確認しましょう。<br/>
もうこれだけでダイスボットとしての形は整ったことになります！<br/>
<br/>
試しにどどんとふで実際に動かしてみましょう。<br/>
どどんとふサーバ上の　src_bcdice/diceBot　に　KariDice.rb　を置いてログイン。<br/>
ダイスボット一覧の一番下に「仮ダイス」が表示されましたね。<br/>
いい感じです！<br/>
<br/>
<h2>■自作ダイスボットの作り方：その３　テストファースト！</h2>
では、今回実装する予定の判定コマンドを実装していきましょう。<br/>
定義はこうでしたね。<br/>
<br/>
<hr/>
・判定方法<br/>
　6面ダイスをX個振るシステム。<br/>
　判定コマンドは<br/>
　　KDx>=y（xはダイスロール数、yは目標値）<br/>
<hr/>
<br/>
これを実装するには、<br/>
<pre><code>
  def prefixs
    []
  end
</code></pre>
と<br/>
<pre><code>
  def rollDiceCommand(command)
    ''
  end
</code></pre>
の２つのメソッドを書き換えることになります。<br/>
引数の　command　にダイスボットとして入力した文字列が渡されますので、そこからロールの判定を行い、結果の文字列を戻り値に渡せばOKです。<br/>
では早速実装！<br/>
…とその前に、動作テストの用意をしましょう。<br/>
どどんとふのダイスボットは作成時に動作検証をしやすいように動作テスト用の仕組みが用意されています（ユニットテストと呼ばれるものですね）。<br/>
これを活用すればダイスボットが正しく動いているかをどどんとふ上で確認しなくてもよいのでとっても楽です。<br/>
どどんとふ なら　src_bcdice/test<br/>
B＆C Dice2.0 なら　src/test　に移動。<br/>
そこにある　test.rb　がテスト用のスクリプト、　testData.txt　がテスト用のデータです。<br/>
では　testData.txt　を開きましょう。<br/>
<br/>
<hr/>
============================<br/>
input:1D100<=10	Cthulhu<br/>
output:<br/>
Cthulhu : (1D100<=10) ＞ 98 ＞ 致命的失敗<br/>
rand:98/100<br/>
============================<br/>
input:1D100<=10	Cthulhu<br/>
output:<br/>
Cthulhu : (1D100<=10) ＞ 45 ＞ 失敗<br/>
rand:45/100<br/>
============================<br/>
<hr/>
<br/>
といった記述が並んでいますね。<br/>
ここに自分用のテストを追加しましょう。<br/>
<br/>
読み方は簡単で<br/>
<br/>
<hr/>
============================<br/>
input:（テストしたいデータ）（タブ）（ダイスボットの型名）<br/>
output:<br/>
（ダイスボットの型名） : （出力される文字列）<br/>
rand:（テストしたいダイスの出目）<br/>
<hr/>
<br/>
こうです。<br/>
<br/>
input のタブの箇所。ここの区切り文字は空白ではなくタブ（\t）です。<br/>
output の「（ダイスボットの型名）：」はダイスボットの内部で自動的に生成されるので常に必要です。<br/>
実際に表示される文字を意識したいので、省略はできなくなっています。<br/>
rand の記述は　1/6,2/6　のように　（出目）/（ロールするダイス）　の形で記述します。<br/>
これを使えば3D6で1,1,1を出すようなパターンでも　1/6,1/6,1/6 と記述してしまえばすぐ検証できるわけですね。便利！<br/>
<br/>
今回のテストとして　testData.txt　の末尾に以下を追加しましょう。<br/>
<br/>
<hr/>
============================<br/>
input:KD3>=10	KariDice<br/>
output:<br/>
KariDice : (KD3>=10) ＞ 10[2,5,3] ＞ 成功<br/>
rand:2/6,5/6,3/6<br/>
============================<br/>
input:KD3>=10	KariDice<br/>
output:<br/>
KariDice : (KD3>=10) ＞ 9[1,5,3] ＞ 失敗<br/>
rand:1/6,5/6,3/6<br/>
<hr/>
<br/>
そしてテストの実行。<br/>
<br/>
ruby test.rb KariDice<br/>
<br/>
とコマンドを実行。<br/>
<br/>
<hr/>
ruby test.rb KariDice<br/>
xx<br/>
===========================<br/>
index:5955<br/>
input:KD3>=10	KariDice<br/>
result:<br/>
	ダイス残り：2/6,5/6,3/6<br/>
good  :<br/>
KariDice : (KD3>=10) ＞ 10[2,5,3] ＞ 成功<br/>
randsText:2/6,5/6,3/6<br/>
===========================<br/>
index:5956<br/>
input:KD3>=10	KariDice<br/>
result:<br/>
	ダイス残り：1/6,5/6,3/6<br/>
good  :<br/>
KariDice : (KD3>=10) ＞ 9[1,5,3] ＞ 失敗<br/>
randsText:1/6,5/6,3/6<br/>
<hr/>
<br/>
と出力されます。<br/>
<br/>
これは「xx」とｘが２つなので「テスト2件に失敗」を示します。成功なら「..」となって、「OK」が表示されます。<br/>
ここでは判定成功時と失敗時の2件の動作を確認して、両方に失敗したということですね。<br/>
早く「OK」が表示されるのが楽しみですね！<br/>
<br/>
以後はソースコードを変更したらテストを実行して動作を確認、<br/>
新しい実装をする時には先にですとデータを作って、動作確認、を繰り返すことになります。<br/>
テスト→実装→テスト→実装…の順ですね。<br/>
<br/>
ちなみ、こうやって先にテストを作ってからプログラムを作成する方法をテストファーストって呼んだりします。<br/>
是非実績していきましょう！<br/>
<br/>
<h2>■自作ダイスボットの作り方：その４　そして実装</h2>
準備もできたので、ダイスボットの実装を。<br/>
<br/>
まずはコマンドの定義を<br/>
<pre><code>
  def prefixs
    ['KD\d+>=\d+']
  end
</code></pre>
ここに書いて、どどんとふにコマンドを教えてやる必要があります。忘れがちなので注意！<br/>
ポイントは、文字列を””ではなく’’で囲むことですね。<br/>
こうしないと￥ｄのｄが￥文字でエスケープされてしまい、「￥ｄ」という文字にならないのですね。<br/>
正規表現相当の文字をここで文字列として定義してRubyとActionScript両方で使っているので、扱いにクセがあります。<br/>
分かりにくい場合は、今後の拡張性も考えて<br/>
</code></pre>
    ['KD.*']<br/>
</code></pre>
みたいに手を抜いた記述にしてしまうのも手です。<br/>
とりあえず動かしてみたいですしね。<br/>
次にコマンドの判定部分を実装。<br/>
<pre><code>
  def rollDiceCommand(command)
    debug("rollDiceCommand Begin")
    
    return '' unless( /^KD(\d+)>=(\d+)$/ =~ command )
    
    debug("command", command)
    
    diceCount = $1.to_i
    target = $2.to_i
    
    total, diceText, = roll(diceCount, 6)
    result = (total >= target ? "成功" : "失敗")
    
    text = "(#{command}) ＞ #{total}[#{diceText}] ＞ #{result}"
    debug("rollDiceCommand result")
    
    return text
  end
</code></pre>
これで成否判定は実装完了。<br/>
rollメソッドはDiceBotクラスで実装済みのメソッドで、<br/>
    合計, ダイスの文字列, [その他のデータ] = roll(ダイス数, ダイス種別)<br/>
みたいに使います。今回は[その他のデータ]は使わないので省略して<br/>
　合計, ダイスの文字列, ＝<br/>
となっています。　＝　の直前に「,」があるのがポイントです。<br/>
この書き方で[その他のデータ]は無視するよーって宣言しているわけですね。<br/>
あと、<br/>
<pre><code>
　debug("rollDiceCommand Begin")
</code></pre>
と書いている箇所はデバッグ用の文字列です。<br/>
さっきテストを実行したときに<br/>
<br/>
<hr/>
===========================<br/>
index:5955<br/>
input:KD3>=10	KariDice<br/>
<hr/>
<br/>
みたいな表示がありましたが、ここにあるindexというのはテストの通番でして、<br/>
<br/>
　ruby test.rb 5955<br/>
<br/>
のようにテスト時にダイスボット名の代わりにインデックス番号を指定してあげることができます。<br/>
その場合テスト１件だけを実行し、デバッグ文が出力されます。<br/>
<br/>
　debug("command", command)<br/>
<br/>
と書くと<br/>
<br/>
　command : "KD3>=10"<br/>
<br/>
みたいにデバッグ文が出力されるので読みやすく検証に便利です。<br/>
つまりテストでは<br/>
<br/>
　ruby test.rb （ダイスボット名）<br/>
<br/>
で全体を確認しつつ、失敗パターンをピックアップ確認したいときは<br/>
<br/>
　ruby test.rb （インデックス番号）<br/>
<br/>
で実行。これがテストの王道ということですね。<br/>
<br/>
あ、ちなみに<br/>
<br/>
　ruby test.rb<br/>
<br/>
だけなら全ダイスボットのテストが実行されます。<br/>
最後の最後に試しておくと、他に影響与えてないことが確認できて安心です。<br/>
<br/>
さてさて、では先ほど提示した内容を実装してテストしてみましょう。<br/>
<br/>
<hr/>
ruby test.rb KariDice<br/>
..<br/>
OK.<br/>
<hr/>
<br/>
「OK」が表示されました！やったね！！<br/>
<br/>
<h2>■終わりに</h2>
ここまでできれば後は同じことを繰り返してダイスボットの実装ができます。<br/>
<br/>
まとめると<br/>
<br/>
　テストファーストでテスト作成し失敗することを確認。<br/>
　→コードを実装、テスト。<br/>
　→うまく動かなかったらインデックス指定しデバッグ表示で内容確認。<br/>
　→OKが表示されたら祝杯！<br/>
<br/>
こんな感じですね。<br/>
<br/>
テストデータの作成にはパターンの網羅や以上・以下の閾値確認など色々ポイントがあるんですが、<br/>
それ書き出すとまた長文になりそうなので各自で工夫してみてくださいね。<br/>
<br/>
ではでは！<br/>
<br/>
<br/>
</body>
</html>
